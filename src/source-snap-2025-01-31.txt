// AxlyClient.ts
import axios, { AxiosError, AxiosResponse, CancelTokenSource } from "axios";
import {
  errorInterceptor,
  requestInterceptor,
  responseInterceptor,
} from "./interceptors/index.js";
import { ApiResponse, AxlyError, RequestOptions } from "./types/index.js";
import { isEmpty } from "./utils/index.js";

class AxlyClient {
  private static instance: AxlyClient | null = null;
  private token: string | null = null;
  private cancelTokenSource: CancelTokenSource = axios.CancelToken.source();
  private baseURL: string;
  private toastHandler?: (
    message: string,
    type: "success" | "error" | "warning",
  ) => void;
  private constructor(baseURL: string = "") {
    this.baseURL = baseURL;
  }
  static getInstance(baseURL: string = ""): AxlyClient {
    if (!AxlyClient.instance) {
      AxlyClient.instance = new AxlyClient(baseURL);
    }
    return AxlyClient.instance;
  }
  setToken(token: string): void {
    this.token = token;
  }
  setBaseURL(baseURL: string): void {
    this.baseURL = baseURL;
  }
  setToastHandler(
    toastHandler: (
      message: string,
      type: "success" | "error" | "warning",
    ) => void,
  ): void {
    this.toastHandler = toastHandler;
  }
  private createProgressHandler(
    onProgress?: (progress: number) => void,
  ): ((progressEvent: any) => void) | undefined {
    if (!onProgress) return undefined;
    return (progressEvent: any) => {
      const percentCompleted = Math.round(
        (progressEvent.loaded * 100) / (progressEvent.total || 1),
      );
      onProgress(percentCompleted);
    };
  }
  async request(options: RequestOptions): Promise<AxiosResponse<ApiResponse>> {
    const {
      method = "GET",
      data,
      url,
      contentType,
      customHeaders,
      responseType,
      params,
      baseURL,
      toastHandler: requestToastHandler,
      successToast = false,
      errorToast = false,
      customToastMessage,
      customErrorToastMessage,
      customToastMessageType = "success",
      customErrorToastMessageType = "error",
      onUploadProgress,
      onDownloadProgress,
      cancelable = false,
      onCancel,
    } = options;
    const instance = axios.create({
      baseURL: baseURL || this.baseURL,
      headers: {
        "Content-Type": isEmpty(contentType) ? "application/json" : contentType,
        ...customHeaders,
      },
      responseType: responseType || "json",
      cancelToken: cancelable ? this.cancelTokenSource.token : undefined,
    });
    instance.interceptors.request.use(requestInterceptor(this.token));
    instance.interceptors.response.use(
      responseInterceptor(
        successToast,
        customToastMessage,
        customToastMessageType,
        requestToastHandler || this.toastHandler,
      ),
      errorInterceptor(
        errorToast,
        customErrorToastMessage,
        customErrorToastMessageType,
        requestToastHandler || this.toastHandler,
      ),
    );
    try {
      const response = await instance.request({
        method,
        data,
        url,
        params,
        onUploadProgress: this.createProgressHandler(onUploadProgress),
        onDownloadProgress: this.createProgressHandler(onDownloadProgress),
      });
      return response;
    } catch (error) {
      const axiosError = error as AxiosError<ApiResponse>;
      if (axios.isCancel(error)) {
        if (onCancel) onCancel();
        throw new AxlyError("Request canceled", "CANCELED");
      }
      throw new AxlyError(
        axiosError.response?.data?.message || "An error occurred",
        axiosError.response?.status?.toString() || "UNKNOWN_ERROR",
        axiosError.response?.data,
      );
    }
  }
  cancelRequest(message: string = "Request canceled by the user"): void {
    this.cancelTokenSource.cancel(message);
    this.cancelTokenSource = axios.CancelToken.source();
  }
}

export const client = AxlyClient.getInstance();
export default AxlyClient;


// index.ts
/**
 * @module Axly
 * A modern HTTP client library with React integration
 *
 * @example
 * // Configure client once
 * import { client } from 'axly';
 *
 * client.setToken("your-auth-token");
 * client.setBaseURL("https://api.example.com");
 *
 * @example
 * // React hook usage
 * import { useAxly } from 'axly';
 *
 * const { data } = useAxly({ url: "/data" });
 */
export { default as AxlyClient, client } from "./AxlyClient.js";
export { default as useAxly } from "./hooks/useAxly.js";


// interceptors\error.ts
import { AxiosError } from "axios";
import { ApiResponse, AxlyError } from "../types/index.js";

export const errorInterceptor = (
  errorToast: boolean = false,
  customErrorToastMessage?: string,
  customToastMessageType: "error" | "warning" = "error",
  toastHandler?: (
    message: string,
    type: "success" | "error" | "warning",
  ) => void,
) => {
  return (error: AxiosError<ApiResponse>) => {
    if (errorToast && toastHandler) {
      const message =
        customErrorToastMessage ||
        error.response?.data?.message ||
        "An error occurred";
      toastHandler(message, customToastMessageType);
    }
    throw new AxlyError(
      error.response?.data?.message || "An error occurred",
      error.response?.status?.toString() || "UNKNOWN_ERROR",
      error.response?.data,
    );
  };
};


// interceptors\index.ts
export * from "./error.js";
export * from "./request.js";
export * from "./response.js";


// interceptors\request.ts
import { InternalAxiosRequestConfig } from "axios";

export const requestInterceptor = (token: string | null) => {
  return async (config: InternalAxiosRequestConfig) => {
    if (token && config.headers) {
      config.headers["Authorization"] = `Bearer ${token}`;
    }
    return config;
  };
};


// interceptors\response.ts
import { AxiosResponse } from "axios";
import { ApiResponse } from "../types/index.js";

export const responseInterceptor = (
  successToast: boolean = false,
  customToastMessage?: string,
  customToastMessageType: "success" | "error" | "warning" = "success",
  toastHandler?: (
    message: string,
    type: "success" | "error" | "warning",
  ) => void,
) => {
  return (response: AxiosResponse<ApiResponse>) => {
    if (successToast && toastHandler) {
      const message = customToastMessage || response.data.message;
      if (message) {
        toastHandler(message, customToastMessageType);
      }
    }
    return response;
  };
};


// types\ApiResponse.ts
export interface ApiResponse<T = unknown> {
  message: string;
  data?: T;
  statusCode?: number;
  success?: boolean;
}


// types\ErrorTypes.ts
export class AxlyError<T = unknown> extends Error {
  public code: string;
  public data?: T;
  public isRetryable?: boolean;
  public status?: number;
  constructor(
    message: string,
    code: string,
    data?: T,
    isRetryable?: boolean,
    status?: number,
  ) {
    super(message);
    this.name = "AxlyError";
    this.code = code;
    this.data = data;
    this.isRetryable = isRetryable;
    this.status = status;
    Object.setPrototypeOf(this, AxlyError.prototype);
  }
}


// types\index.ts
export * from "./ApiResponse.js";
export * from "./ErrorTypes.js";
export * from "./RequestOptions.js";


// types\RequestOptions.ts
import { AxiosRequestConfig } from "axios";

export interface RequestOptions {
  method: AxiosRequestConfig["method"];
  data?: any;
  url: string;
  contentType?: string;
  customHeaders?: Record<string, string>;
  responseType?: AxiosRequestConfig["responseType"];
  params?: Record<string, unknown>;
  baseURL?: string;
  toastHandler?: (
    message: string,
    type: "success" | "error" | "warning",
  ) => void;
  successToast?: boolean;
  errorToast?: boolean;
  customToastMessage?: string;
  customErrorToastMessage?: string;
  customToastMessageType?: "success" | "error" | "warning";
  customErrorToastMessageType?: "error" | "warning";
  onUploadProgress?: (progress: number) => void;
  onDownloadProgress?: (progress: number) => void;
  cancelable?: boolean;
  onCancel?: () => void;
}


// utils\index.ts
export { default as isEmpty } from "./isEmpty.js";
export { default as isString } from "./isString.js";


// utils\isEmpty.ts
/**
 * Checks if a value is empty.
 *
 * @param {any} value - The value to check.
 * @returns {boolean} - Returns true if the value is empty, otherwise false.
 */
const isEmpty = (value: unknown): boolean => {
  if (value == null) return true;
  if (Array.isArray(value) || typeof value === "string") {
    return value.length === 0;
  }
  if (value instanceof Set || value instanceof Map) {
    return value.size === 0;
  }
  if (typeof value === "object") {
    return Object.keys(value).length === 0;
  }
  return false;
};

export default isEmpty;


// utils\isString.ts
/**
 * Checks if a value is of type string.
 *
 * @param {any} value - The value to check.
 * @returns {boolean} - Returns true if the value is a string, otherwise false.
 */
const isString = (value: unknown): value is string => typeof value === "string";

export default isString;

